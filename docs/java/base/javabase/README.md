## Java基础知识

### **1. 基本类型和扩展类型是什么？**

**基本类型**

基本类型是Java本身提供的基本数据类型，存储的为值本身，包含八种：
* 字节型byte
* 字符型char
* 整形short、int、long
* 浮点型double、float
* 布尔型boolean

占用空间如图：
> java编程思想第四版-2.2.2节  
![](images/basetype.jpg)

**扩展类型**

扩展类型是根据基本类型扩展出的其他类型，如类、数组、字符串、枚举。存储的为内存的地址引用，也叫引用类型。

### **1. 重写和重载的区别？**

**重写**：发生在父类子类之间，子类重写父类方法。方法名、参数类型、数量、顺序必须相同，返回类型范围小于等于父类，访问修饰符大于等于父类，不能重写父类private方法。

**重载**：发生在同一个类内，方法名相同，参数类型、数量、顺序不同，访问修饰符和返回值可以不同。
### **2. 拆箱与装箱是什么？**

**拆箱**：包装类转化为基本类型的过程
**装箱**：基本类型包装为包装类型的过程

### **3. 构造方法是什么？**

构造方法（Constructor）是一种特殊的方法，方法名与类名一样，没有返回值。当创建对象时，会默认调用构造方法完成对象的初始化，与普通方法一样支持重载。

### **4. 构造方法能否被重写？**

不能。因为父类的私有方法和构造方法不能被重写，子类只是拥有父类的构造方法，子类可以通过super关键字显式调用父类构造方法，如果子类没有显式声明构造方法，那么子类初始化时会隐式调用父类的无参构造方法。

### **5. 接口和抽象类有什么区别？**

* 访问修饰符：接口默认为`public`，抽象类可以有`public`、`protected`、`default`这些，但是都不能有`private`（我理解因为这两位存在的意义就是被子类重写的，所以不能有private的存在）
* 方法描述：接口只负责描述方法，不能有实现（Java8开始接口的方法也可以有默认实现）；抽象类可以只描述方法，也可以实现方法
* 实现方式：一个类可以实现（`implements`）多个接口，但是只能继承（`extends`）一个抽象方法

*备注：在JDK8中，接口也可以定义静态方法，可以直接用接口名调用。实现类和实现是不可以调用的。如果同时实现两个接口，接口中定义了一样的默认方法，则必须重写，不然会报错。(引用自：https://github.com/Snailclimb/JavaGuide/issues/146)*

### **6. 成员变量和局部变量的区别有哪些？**
* 从归属来看：成员变量属于类的一部分，局部变量属于方法
* 从修饰符来看：成员变量可以使用修饰符来控制作用域，而局部变量不能用除了final的修饰符
* 从内存归属来看：如果成员变量使用`static`修饰，则其是属于类的，在类加载时便在方法区分配了内存空间，若果没有使用`static`修饰，则其属于类的实例，实例化的时候在堆中分配了内存；局部变量则是方法执行时在栈中划分的内存
* 从生命周期来看：成员变量的生命周期是随着类或者对象来创建和消亡的；局部变量是随着方法执行而创建和消亡
* 从赋值来看：成员变量会自动赋值（`final`修饰除外）；局部变量声明时必须有初始值

### **7. 对象实体和对象引用有什么区别？**
* 对象实体在堆内存，对象引用在栈内存
* 一个对象引用要么指向`null`，要么指向一个堆内存的对象实例；对象的实例可以没有引用指向它，也可以有多个对象引用指向它

### **8. ==和equals方法有什么区别？（重要）**

**==**：基本类型比较两边的值是否相等，引用类型比较两边的引用的内存地址是否相等

**equals**：因为`equals`方法属于基类Object的方法，因此分情况：

* 如果没有重写，则等价于==
* 如果重写了equals，则根据重写的方法比较。

最经典的String类重写了equals方法，内容是比较字符串的值是否相等，一个示例来说明：
```java
String a = "123";
String b = new String("123");
String c = "123456";
String d = "123" + "456";
System.out.println(a == b);// false 因为a是从常量池创建，b使用了new关键字，内存地址在堆中
System.out.println(a.equals(b));// true a和b的值相等
System.out.println(c == d);// true 对于"123" + "456"这种写法，编译器自动优化为"123456"
System.out.println(c.equals(d));// true
```
### **9.  hashCode是什么？**

`hashCode()`方法是基类的一个原生方法，返回一个int型值，作用是确定该对象在哈希表中的索引位置。它是根据内存地址计算得出，因此会存在hash冲突的现象，它具有以下特性：
* 如果两个对象相等，那么hashCode也是相等的
* 如果两个对象的hashCode相等，这两个对象不一定相等
* 如果equals方法被重写，则hashCode方法一定要被重写

`关于hashCode和equals的更详细解释移步：https://www.cnblogs.com/skywang12345/p/3324958.html`

### **10. 形参和实参分别是什么？**
**形式参数**：简称形参，是对方法所需参数的一种描述。在进行方法调用时才被初始化。  
**实际参数**：简称实参，是指方法被调用时实际传入的值。在进行方法调用前已经被初始化。

*PS. 个人理解，形参和实参更多的是编程语言为了方便区分而设置的理念性的东西，是相对于方法来说的：  
形参是方法对所需值的描述，它只在方法执行时作为传入参数的标识而存在，方法执行完形参的引用即被销毁（出栈）；  
实参是对方法调用时真实传进来的值的描述，它包含真实的内存地址或值，这个根据编程语言不同会有差别。*

### **11. 值传递和引用传递有什么区别？**
**值传递**： 方法接收的是实参的真实值。  
**引用传递**：方法接收的是实参的内存地址，形参和实参此时都引用了一块堆内存（关于堆内存会在之后的JVM内存划分中详细整理）。

### **12. Java中方法的调用是值传递还是引用传递？**
*这个问题的内容是根据我的理解来写的，如果各位看到后思考一下，如果不妥，还请联系我讨论下~*

先说结论：Java中会同时存在值传递和引用传递。

我们看一段代码：
```java
public static void main(String[] args) {
    int a = 0;
    Map<String, Object> map = new HashMap<>();
    String str = "str";
    map.put("a", a);
    System.out.println("方法调用前：");
    System.out.println("a= " + a);
    System.out.println("map.a= " + map.get("a"));
    System.out.println("str= " + str);
    method(a, map, str);
    System.out.println("方法调用后：");
    System.out.println("a= " + a);
    System.out.println("str= " + str);
}

private static void method(int a, Map<String, Object> map, String str) {
    a = 1;
    map.put("a", a);
    str = "abc";
}
```

执行结果如下：
```java
方法调用前：
a= 0
map.a= 0
str= str
方法调用后：
a= 0
map.a= 1
str= str
```

可以看到方法执行前后，第一个和第三个参数的值没有被修改，第二个参数的值被成功修改了。  
为什么呢？这是由于Java的内存机制决定的：在Java中，方法的局部变量是存储在栈内存中，对于基本类型，栈帧中存储的是值，而对于引用类型，栈帧中存储的是堆内存地址。  
在上面例子中，我们一步步分析：
1. `method`方法入栈时，`a`是一个`int`类型，因此在栈中创建了局部变量`a`，值为0，`map`是一个引用类型，因此在栈中创建了变量`map`，值为实参的内存地址，`str`作为引用类型也拿到了一个内存地址；
2. `method`方法开始执行，先把变量`a`重新赋值，这时`method`栈帧中的变量`a`的值被改掉，但是并不会影响`main`方法栈中的`a`的值，因为本来就是两块内存，独立互不影响；
3. 然后将`map`中的`a`覆盖，这时候程序其实是先找到了`map`引用的内存地址，根据地址在堆内存中找到了`map`的实例，修改了堆内存中的值。而由于`main`方法栈中的`map`也是引用的这块内存，所以等同于它的内存也被修改了；
4. 另外，关于`String`类型的变量`str`为什么没有被成功修改呢？这是因为`String`是一个`final`类型，并且每次在对`String`类型重新赋值时，JVM都会开辟新的内存空间（*当然还有字符串常量池的存在，再议*），`method`栈帧中`str`的内存地址被替换了，因此对`main`中`str`引用的内存不会有影响。

总而言之：
* 对于基本类型，采取值传递
* 对于引用类型，采用引用传递